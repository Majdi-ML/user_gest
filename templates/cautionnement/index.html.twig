{% extends 'base.html.twig' %}

{% block title %}Liste des Frais Syndics{% endblock %}

{% block css %}
    {{ parent() }}
    <link href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css" rel="stylesheet">
    <style>
        .filter-row th {
            padding: 8px 3px !important;
            vertical-align: top;
        }
        .filter-container {
            display: flex;
            gap: 5px;
            align-items: center;
            margin-bottom: 10px;
        }
        .filter-select {
            width: 100%;
            min-width: 120px;
        }
        .filter-input {
            width: 100%;
            min-width: 150px;
        }
        .btn-add-condition {
            margin-top: 5px;
        }
        .date-filter {
            display: none;
        }
        .logic-operator {
            font-weight: bold;
            margin: 0 10px;
        }
        .export-buttons {
            margin-bottom: 20px;
        }
    </style>
{% endblock %}

{% block body %}
<div class="container mt-4">
    <h1 class="mb-4">ðŸ’° Frais Syndic</h1>

    <div class="mb-3 text-end">
        <a href="{{ path('app_cautionnement_new') }}" class="btn btn-success">âž• Nouveau </a>
    </div>

    <div class="card mb-4">
        <div class="card-header">
            <h5 class="mb-0">Filtres AvancÃ©s</h5>
        </div>
        <div class="card-body">
            <div class="mb-3">
                <div class="form-check form-check-inline">
                    <input class="form-check-input" type="radio" name="filterLogic" id="filterLogicAnd" value="AND" checked>
                    <label class="form-check-label" for="filterLogicAnd">Toutes les conditions (AND)</label>
                </div>
                <div class="form-check form-check-inline">
                    <input class="form-check-input" type="radio" name="filterLogic" id="filterLogicOr" value="OR">
                    <label class="form-check-label" for="filterLogicOr">Au moins une condition (OR)</label>
                </div>
            </div>
            
            <div id="filterBuilder">
                <!-- Les filtres seront ajoutÃ©s ici dynamiquement -->
            </div>
            <button id="addFilterBtn" class="btn btn-primary btn-sm btn-add-condition mt-2">
                <i class="bi bi-plus"></i> Ajouter une condition
            </button>
            <button id="applyFiltersBtn" class="btn btn-success btn-sm mt-2">
                <i class="bi bi-funnel"></i> Appliquer les filtres
            </button>
            <button id="resetFiltersBtn" class="btn btn-danger btn-sm mt-2">
                <i class="bi bi-x-circle"></i> RÃ©initialiser
            </button>
        </div>
    </div>

    <div class="export-buttons text-end">
        <button id="exportPdfBtn" class="btn btn-danger btn-sm me-2">
            <i class="bi bi-file-pdf"></i> Exporter en PDF
        </button>
        <button id="exportExcelBtn" class="btn btn-success btn-sm">
            <i class="bi bi-file-excel"></i> Exporter en Excel
        </button>
    </div>

    <div class="alert alert-info">
        ðŸ’µ Total des Frais : <strong id="totalMontant">{{ totalMontant }} TND</strong>
    </div>

    <div class="table-responsive">
        <table id="cautionnementsTable" class="table table-bordered table-hover align-middle">
            <thead class="table-light">
                <tr>
                    <th>Montant</th>
                    <th>Date de Paiement</th>
                    <th>Mois</th>
                    <th>AnnÃ©e</th>
                    <th>Nature Paiement</th>
                    <th>Personne</th>
                    <th>Appartement</th>
                    <th>Utilisateur (email)</th>
                    <th>Actions</th>
                </tr>
            </thead>
            <tbody>
            {% for c in cautionnements %}
                <tr data-id="{{ c.id }}"
                    data-montant="{{ c.montant ? c.montant.montant : '' }}"
                    data-date-paiement="{{ c.datePaiement ? c.datePaiement|date('Y-m-d') : '' }}"
                    data-mois="{{ c.mois }}"
                    data-annee="{{ c.annee }}"
                    data-nature-paiement="{{ c.naturePaiement ? c.naturePaiement.nature : '' }}"
                    data-personne="{{ c.personne ? c.personne.nom ~ ' ' ~ c.personne.prenom : '' }}"
                    data-appartement="{{ c.Appartement ? c.Appartement : '' }}"
                    data-utilisateur="{{ c.user ? c.user.email : '' }}">
                    <td>
                        {% if c.montant %}
                            {{ c.montant.montant }} TND
                        {% else %}
                            â€”
                        {% endif %}
                    </td>
                    <td>{{ c.datePaiement ? c.datePaiement|date('d/m/Y') : '' }}</td>
                    <td>{{ c.mois }}</td>
                    <td>{{ c.annee }}</td>
                    <td>{{ c.naturePaiement ? c.naturePaiement.nature : 'â€”' }}</td>
                    <td>
                        {% if c.personne %}
                            {{ c.personne.nom }} {{ c.personne.prenom }}
                        {% else %}
                            â€”
                        {% endif %}
                    </td>
                    <td>{{ c.Appartement ? c.Appartement : 'â€”' }}</td>
                    <td>{{ c.user ? c.user.email : 'â€”' }}</td>
                    <td>
                        <a href="{{ path('app_cautionnement_show', {'id': c.id}) }}" class="btn btn-sm btn-outline-primary">Afficher</a>
                        <a href="{{ path('app_cautionnement_edit', {'id': c.id}) }}" class="btn btn-sm btn-outline-secondary">Modifier</a>
                    </td>
                </tr>
            {% else %}
                <tr>
                    <td colspan="9" class="text-center">Aucun cautionnement trouvÃ©.</td>
                </tr>
            {% endfor %}
            </tbody>
            {% if cautionnements|length > 0 %}
                <tfoot>
                    <tr class="table-info fw-bold">
                        <td id="totalMontantFooter">{{ totalMontant }} TND</td>
                        <td colspan="8"></td>
                    </tr>
                </tfoot>
            {% endif %}
        </table>
    </div>
</div>
{% endblock %}

{% block js %}
    {{ parent() }}
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
    <script src="https://cdn.jsdelivr.net/npm/flatpickr/dist/l10n/fr.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.8.2/jspdf.plugin.autotable.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script>
        $(document).ready(function() {
            // DonnÃ©es pour les colonnes
            const columnData = {
                montant: { type: 'number' },
                'date-paiement': { type: 'date' },
                mois: { type: 'text' },
                annee: { type: 'number' },
                'nature-paiement': { type: 'text' },
                personne: { type: 'text' },
                appartement: { type: 'text' },
                utilisateur: { type: 'text' }
            };
            
            // OpÃ©rateurs par type de colonne
            const textOperators = [
                { id: 'equals', text: 'Ã‰gal Ã ' },
                { id: 'not_equals', text: 'DiffÃ©rent de' },
                { id: 'contains', text: 'Contient' },
                { id: 'not_contains', text: 'Ne contient pas' },
                { id: 'starts_with', text: 'Commence par' },
                { id: 'ends_with', text: 'Finit par' },
                { id: 'empty', text: 'Est vide' },
                { id: 'not_empty', text: "N'est pas vide" }
            ];
            
            const numberOperators = [
                { id: 'equals', text: 'Ã‰gal Ã  (=)' },
                { id: 'not_equals', text: 'DiffÃ©rent de (!=)' },
                { id: 'greater', text: 'SupÃ©rieur Ã  (>)' },
                { id: 'greater_equal', text: 'SupÃ©rieur ou Ã©gal (>=)' },
                { id: 'less', text: 'InfÃ©rieur Ã  (<)' },
                { id: 'less_equal', text: 'InfÃ©rieur ou Ã©gal (<=)' },
                { id: 'empty', text: 'Est vide' },
                { id: 'not_empty', text: "N'est pas vide" }
            ];
            
            const dateOperators = [
                { id: 'equals', text: 'Ã‰gal Ã ' },
                { id: 'not_equals', text: 'DiffÃ©rent de' },
                { id: 'greater', text: 'AprÃ¨s le' },
                { id: 'greater_equal', text: 'AprÃ¨s ou Ã©gal' },
                { id: 'less', text: 'Avant le' },
                { id: 'less_equal', text: 'Avant ou Ã©gal' },
                { id: 'between', text: 'Entre' },
                { id: 'empty', text: 'Est vide' },
                { id: 'not_empty', text: "N'est pas vide" }
            ];
            
            // Ajouter un nouveau filtre
            function addFilter() {
                const filterId = Date.now();
                const filterHtml = `
                <div class="filter-container" data-filter-id="${filterId}">
                    <select class="form-select form-select-sm filter-column" style="width: 150px;">
                        ${Object.keys(columnData).map(col => 
                            `<option value="${col}">${col.replace('date-paiement', 'Date de Paiement').replace('nature-paiement', 'Nature Paiement').replace('-', ' ').charAt(0).toUpperCase() + col.replace('date-paiement', 'Date de Paiement').replace('nature-paiement', 'Nature Paiement').replace('-', ' ').slice(1)}</option>`
                        ).join('')}
                    </select>
                    <select class="form-select form-select-sm filter-operator" style="width: 180px;">
                        ${textOperators.map(op => `<option value="${op.id}">${op.text}</option>`).join('')}
                    </select>
                    <input type="text" class="form-control form-control-sm filter-value" placeholder="Valeur" style="display: none;">
                    <input type="number" class="form-control form-control-sm filter-value-number number-filter" placeholder="Valeur numÃ©rique" style="display: none;">
                    <input type="text" class="form-control form-control-sm filter-value-date date-filter" placeholder="Date" style="display: none;">
                    <div class="date-range-filter" style="display: none; gap: 5px;">
                        <input type="text" class="form-control form-control-sm filter-value-date-start" placeholder="Date dÃ©but">
                        <span>et</span>
                        <input type="text" class="form-control form-control-sm filter-value-date-end" placeholder="Date fin">
                    </div>
                    <button class="btn btn-danger btn-sm remove-filter" type="button">
                        <i class="bi bi-trash"></i>
                    </button>
                </div>
                `;
                $('#filterBuilder').append(filterHtml);
                
                // Initialiser le datepicker
                $(`[data-filter-id="${filterId}"] .date-filter`).flatpickr({
                    dateFormat: "d/m/Y",
                    locale: "fr"
                });
                
                $(`[data-filter-id="${filterId}"] .filter-value-date-start, [data-filter-id="${filterId}"] .filter-value-date-end`).flatpickr({
                    dateFormat: "d/m/Y",
                    locale: "fr"
                });
                
                // Mettre Ã  jour les opÃ©rateurs et les champs de valeur quand la colonne change
                $(`[data-filter-id="${filterId}"] .filter-column`).change(function() {
                    updateFilterInputs(filterId);
                }).trigger('change');
                
                // Mettre Ã  jour le champ de valeur quand l'opÃ©rateur change
                $(`[data-filter-id="${filterId}"] .filter-operator`).change(function() {
                    updateFilterInputs(filterId);
                });
            }
            
            // Mettre Ã  jour les inputs en fonction de la colonne et de l'opÃ©rateur sÃ©lectionnÃ©s
            function updateFilterInputs(filterId) {
                const container = $(`[data-filter-id="${filterId}"]`);
                const column = container.find('.filter-column').val();
                const operator = container.find('.filter-operator').val();
                const columnType = columnData[column].type;
                
                // Mettre Ã  jour les opÃ©rateurs disponibles
                let operators;
                if (columnType === 'number') operators = numberOperators;
                else if (columnType === 'date') operators = dateOperators;
                else operators = textOperators;
                
                const operatorSelect = container.find('.filter-operator');
                const currentOperator = operatorSelect.val();
                operatorSelect.empty();
                operators.forEach(op => {
                    operatorSelect.append(`<option value="${op.id}">${op.text}</option>`);
                });
                
                // Conserver l'opÃ©rateur sÃ©lectionnÃ© si possible
                if (operators.some(op => op.id === currentOperator)) {
                    operatorSelect.val(currentOperator);
                }
                
                // Mettre Ã  jour le champ de valeur
                container.find('.filter-value, .filter-value-number, .filter-value-date, .date-range-filter').hide();
                
                if (operator === 'empty' || operator === 'not_empty') {
                    // Pas de champ de valeur nÃ©cessaire
                } else if (operator === 'between' && columnType === 'date') {
                    container.find('.date-range-filter').show();
                } else {
                    if (columnType === 'date') {
                        container.find('.filter-value-date').show();
                    } else if (columnType === 'number') {
                        container.find('.filter-value-number').show();
                    } else {
                        container.find('.filter-value').show();
                    }
                }
            }
            
            // Ajouter le premier filtre
            addFilter();
            
            // Ajouter un nouveau filtre quand on clique sur le bouton
            $('#addFilterBtn').click(addFilter);
            
            // Supprimer un filtre
            $('#filterBuilder').on('click', '.remove-filter', function() {
                $(this).closest('.filter-container').remove();
            });
            
            // Appliquer les filtres
            $('#applyFiltersBtn').click(function() {
                const filters = [];
                const logic = $('input[name="filterLogic"]:checked').val();
                
                $('.filter-container').each(function() {
                    const column = $(this).find('.filter-column').val();
                    const operator = $(this).find('.filter-operator').val();
                    let value1, value2;
                    
                    if (operator === 'empty' || operator === 'not_empty') {
                        filters.push({ column, operator, logic });
                        return;
                    }
                    
                    if (operator === 'between' && columnData[column].type === 'date') {
                        value1 = $(this).find('.filter-value-date-start').val();
                        value2 = $(this).find('.filter-value-date-end').val();
                        if (!value1 || !value2) return;
                    } else {
                        if (columnData[column].type === 'date') {
                            value1 = $(this).find('.filter-value-date').val();
                        } else if (columnData[column].type === 'number') {
                            value1 = $(this).find('.filter-value-number').val();
                        } else {
                            value1 = $(this).find('.filter-value').val();
                        }
                        if (!value1) return;
                    }
                    
                    filters.push({ column, operator, value1, value2, logic });
                });
                
                applyFilters(filters, logic);
            });
            
            // RÃ©initialiser les filtres
            $('#resetFiltersBtn').click(function() {
                $('#filterBuilder').empty();
                addFilter();
                $('#cautionnementsTable tbody tr').show();
                updateTotalMontant(); // Update total after reset
            });
            
            // Fonction pour appliquer les filtres
            function applyFilters(filters, logic) {
                if (filters.length === 0) {
                    $('#cautionnementsTable tbody tr').show();
                    updateTotalMontant(); // Update total when no filters
                    return;
                }
                
                $('#cautionnementsTable tbody tr').each(function() {
                    const row = $(this);
                    let matchResults = [];
                    
                    filters.forEach(filter => {
                        const column = filter.column;
                        const operator = filter.operator;
                        let value = row.data(column);
                        let matches = false;
                        
                        // GÃ©rer les cas vides
                        if (value === '' || value === null || value === undefined) {
                            if (operator === 'empty') matches = true;
                            else if (operator === 'not_empty') matches = false;
                            else matches = false;
                            
                            matchResults.push(matches);
                            return;
                        }
                        
                        // Convertir les valeurs selon le type
                        if (columnData[column].type === 'number') {
                            value = parseFloat(value);
                            const filterValue = parseFloat(filter.value1);
                            
                            switch(operator) {
                                case 'equals': matches = value === filterValue; break;
                                case 'not_equals': matches = value !== filterValue; break;
                                case 'greater': matches = value > filterValue; break;
                                case 'greater_equal': matches = value >= filterValue; break;
                                case 'less': matches = value < filterValue; break;
                                case 'less_equal': matches = value <= filterValue; break;
                                case 'empty': matches = isNaN(value); break;
                                case 'not_empty': matches = !isNaN(value); break;
                            }
                        } 
                        else if (columnData[column].type === 'date') {
                            const rowDate = new Date(value);
                            let filterDate1, filterDate2;
                            
                            if (operator === 'between') {
                                filterDate1 = new Date(parseDate(filter.value1));
                                filterDate2 = new Date(parseDate(filter.value2));
                                matches = rowDate >= filterDate1 && rowDate <= filterDate2;
                            } else {
                                filterDate1 = new Date(parseDate(filter.value1));
                                
                                switch(operator) {
                                    case 'equals': 
                                        matches = rowDate.getTime() === filterDate1.getTime(); 
                                        break;
                                    case 'not_equals': 
                                        matches = rowDate.getTime() !== filterDate1.getTime(); 
                                        break;
                                    case 'greater': 
                                        matches = rowDate > filterDate1; 
                                        break;
                                    case 'greater_equal': 
                                        matches = rowDate >= filterDate1; 
                                        break;
                                    case 'less': 
                                        matches = rowDate < filterDate1; 
                                        break;
                                    case 'less_equal': 
                                        matches = rowDate <= filterDate1; 
                                        break;
                                }
                            }
                        } 
                        else {
                            // Texte
                            value = String(value).toLowerCase();
                            const filterValue = String(filter.value1).toLowerCase();
                            
                            switch(operator) {
                                case 'equals': matches = value === filterValue; break;
                                case 'not_equals': matches = value !== filterValue; break;
                                case 'contains': matches = value.includes(filterValue); break;
                                case 'not_contains': matches = !value.includes(filterValue); break;
                                case 'starts_with': matches = value.startsWith(filterValue); break;
                                case 'ends_with': matches = value.endsWith(filterValue); break;
                            }
                        }
                        
                        matchResults.push(matches);
                    });
                    
                    // Appliquer la logique AND ou OR
                    let shouldShow;
                    if (logic === 'AND') {
                        shouldShow = matchResults.length > 0 && matchResults.every(m => m);
                    } else { // OR
                        shouldShow = matchResults.some(m => m);
                    }
                    
                    row.toggle(shouldShow);
                });
                
                updateTotalMontant(); // Update total after applying filters
            }
            
            // Helper pour parser les dates au format d/m/Y
            function parseDate(dateStr) {
                const parts = dateStr.split('/');
                return new Date(parts[2], parts[1] - 1, parts[0]);
            }

            // Fonction pour calculer et mettre Ã  jour le total des montants visibles
            function updateTotalMontant() {
                let total = 0;
                $('#cautionnementsTable tbody tr:visible').each(function() {
                    const montantText = $(this).find('td').eq(0).text().replace(' TND', '').trim();
                    const montant = parseFloat(montantText);
                    if (!isNaN(montant)) {
                        total += montant;
                    }
                });
                total = total.toFixed(2); // Format to 2 decimal places
                $('#totalMontant').text(total + ' TND');
                $('#totalMontantFooter').text(total + ' TND');
                return total;
            }

            // Fonction pour collecter les donnÃ©es visibles
            function collectVisibleData() {
                const data = [];
                const headers = ['Montant', 'Date de Paiement', 'Mois', 'AnnÃ©e', 'Nature Paiement', 'Personne', 'Appartement', 'Utilisateur (email)'];
                const total = updateTotalMontant(); // Get the dynamic total

                $('table tbody tr:visible').each(function() {
                    const row = $(this);
                    const montantText = row.find('td').eq(0).text().replace(' TND', '').trim();
                    const rowData = {
                        'Montant': montantText,
                        'Date de Paiement': row.find('td').eq(1).text(),
                        'Mois': row.find('td').eq(2).text(),
                        'AnnÃ©e': row.find('td').eq(3).text(),
                        'Nature Paiement': row.find('td').eq(4).text(),
                        'Personne': row.find('td').eq(5).text(),
                        'Appartement': row.find('td').eq(6).text(),
                        'Utilisateur (email)': row.find('td').eq(7).text()
                    };
                    data.push(rowData);
                });

                // Ajouter la ligne de total si des donnÃ©es sont prÃ©sentes
                if (data.length > 0) {
                    const totalRow = {
                        'Montant': total + ' TND',
                        'Date de Paiement': '',
                        'Mois': '',
                        'AnnÃ©e': '',
                        'Nature Paiement': '',
                        'Personne': '',
                        'Appartement': '',
                        'Utilisateur (email)': ''
                    };
                    data.push(totalRow);
                }

                return { headers, data };
            }

            // Exporter en PDF
            $('#exportPdfBtn').click(function() {
                const { jsPDF } = window.jspdf;
                const doc = new jsPDF();
                const { headers, data } = collectVisibleData();

                // Ajouter un titre
                doc.setFontSize(18);
                doc.text('Liste des Frais Syndics', 14, 22);

                // GÃ©nÃ©rer le tableau
                doc.autoTable({
                    head: [headers],
                    body: data.map(row => headers.map(header => row[header])),
                    startY: 30,
                    theme: 'striped',
                    headStyles: { fillColor: [100, 100, 100] },
                    styles: { fontSize: 10 },
                    didParseCell: function(data) {
                        if (data.row.raw[0].includes('TND') && data.row.raw[1] === '') {
                            data.cell.styles.fontStyle = 'bold';
                            data.cell.styles.fillColor = [200, 230, 255];
                        }
                    }
                });

                // TÃ©lÃ©charger le PDF
                doc.save('frais-syndic.pdf');
            });

            // Exporter en Excel
            $('#exportExcelBtn').click(function() {
                const { headers, data } = collectVisibleData();

                // CrÃ©er une feuille de calcul
                const ws = XLSX.utils.json_to_sheet(data, { header: headers });

                // Appliquer un style pour la ligne de total
                if (data.length > 0 && data[data.length - 1]['Montant'].includes('TND')) {
                    const range = XLSX.utils.decode_range(ws['!ref']);
                    for (let C = range.s.c; C <= range.e.c; ++C) {
                        const cellAddress = XLSX.utils.encode_cell({ r: range.e.r, c: C });
                        if (!ws[cellAddress]) continue;
                        ws[cellAddress].s = {
                            font: { bold: true },
                            fill: { fgColor: { rgb: 'C8E6FF' } }
                        };
                    }
                }

                // CrÃ©er un classeur
                const wb = XLSX.utils.book_new();
                XLSX.utils.book_append_sheet(wb, ws, 'Frais Syndics');

                // TÃ©lÃ©charger le fichier Excel
                XLSX.writeFile(wb, 'frais-syndic.xlsx');
            });

            // Update total on initial load
            updateTotalMontant();
        });
    </script>
{% endblock %}